#!/bin/bash
################################################################################
# Slap Fingerprint Segmentation III Validation                                 #
#                                                                              #
# Place your properly-named library in to lib/ and then execute this script.   #
# If your implementation meets the tested requirements, an archive will be     #
# created for you to send to NIST for evaluation. The output of your           #
# implementation on your hardware must match the output generated at NIST      #
# exactly, so "forcing" the creation of the archive will not speed along your  #
# evaluation results.                                                          #
#                                                                              #
#  E-mail: slapseg@nist.gov                                                    #
#     URL: https://github.com/usnistgov/slapseg                                #
# License: This software was developed at the National Institute of Standards  #
#          and Technology (NIST) by employees of the Federal Government in the #
#          course of their official duties.  Pursuant to title 17 Section 105  #
#          of the United States Code, this software is not subject to          #
#          copyright protection and is in the public domain.  NIST assumes no  #
#          responsibility whatsoever for its use by other parties, and makes   #
#          no guarantees, expressed or implied, about its quality,             #
#          reliability, or any other characteristic.                           #
################################################################################

################################################################################
# Constants                                                                    #
################################################################################

# Time in seconds when this script was launched
start_sec="$(date +%s)"

# URL where the complete validation package can be downloaded
validation_dl_url="https://github.com/usnistgov/slapseg/releases"
# URL where the validation imagery is requested
validation_image_request_url="mailto:slapseg@nist.gov"

# Directory containing validation materials
wd="$(cd "$(dirname "${0}")" && pwd)"
# Directory containing validation images
validation_image_dir="images"
# Directory where libraries go
lib_dir="${wd}"/lib
# Directory where validation driver sourcecode lives
src_dir="${wd}"/src
# Directory where validation driver is built
bin_dir="${wd}"/bin
# Output directory for validation driver logs
output_dir="${wd}"/output
# Path to the compiled validation driver binary
binary="${bin_dir}/slapsegiii_validation"

# Prefix for downloaded validation imagery tarballs
validation_image_download_prefix=slapsegiii_validation_images_
# Names for supported slap types
slap_type_names="twoinch threeinch upperpalm fullpalm"
# Numbers for supported slap types
slap_type_numbers="2 3 5 8"

################################################################################
# Functions                                                                    #
################################################################################

# Dimmed text color
font_dim() { if [ -t 1 ]; then tput dim; fi }
# Green text color
font_green() { if [ -t 1 ]; then tput setaf 2; fi }
# Red text color
font_red() { if [ -t 1 ]; then tput setaf 1; fi }
# Light red text color
font_lightred() { if [ -t 1 ]; then tput setaf 5; fi }
# Yellow text color
font_yellow() { if [ -t 1 ]; then tput setaf 3; fi }
# Underline the text
font_underline() { if [ -t 1 ]; then tput smul; fi }
# Reset to default text color
font_reset() { if [ -t 1 ]; then tput sgr0; fi }

# Print the path of the argument relative to the current working directory
rp()
{
	realpath=realpath
	if [ "$(uname)" == "Darwin" ]; then
		realpath="/opt/local/bin/grealpath"
	fi

	${realpath} --relative-to="${PWD}" "${1}"
}

# Output string in a box
box()
{
	if [ "${#}" -lt 1 ] || [ "${#}" -gt 7 ] ; then
		echo -n "Usage: ${FUNCNAME[0]} <msg> [width=80] "
		echo "[tb_symbol='='] [lr_symbol='|'] [align=[a|l|c|r]] "
		echo "[header=0|1] [footer=0|1]"
		return 1
	fi
	local msg="${1}"
	local width=80
	if [ "${#}" -ge 2 ]; then
		width="${2}"
	fi
	local tb_symbol='='
	if [ "${#}" -ge 3 ]; then
		tb_symbol="${3}"
		if [ "${#tb_symbol}" -ne 1 ]; then
			echo "tb_symbol not a single character"
			return 1
		fi
	fi
	local lr_symbol='|'
	if [ "${#}" -ge 4 ]; then
		lr_symbol="${4}"
		if [ "${#lr_symbol}" -ne 1 ]; then
			echo "lr_symbol not a single character"
			return 1
		fi
	fi
	local align="a"
	if [ "${#}" -ge 5 ]; then
		align="${5}"
		if [ "${align}" != "c" ] && [ "${align}" != "a" ] && \
		    [ "${align}" != "l" ] && [ "${align}" != "r" ]; then
			echo "Invalid alignment value"
			return 1
		fi
	fi
	local print_header=1
	if [ "${#}" -ge 6 ]; then
		print_header="${6}"
		if [ "${print_header}" -ne 0 ] && [ "${print_header}" -ne 1 ]
		then
			echo "Invalid print_header value"
		fi
	fi
	local print_footer=1
	if [ "${#}" -eq 7 ]; then
		print_footer="${7}"
		if [ "${print_footer}" -ne 0 ] && [ "${print_footer}" -ne 1 ]
		then
			echo "Invalid print_footer value"
		fi
	fi

	if [ "${print_header}" -eq 1 ]; then
		printline "${tb_symbol}" "${width}" && echo
	fi

	local max_width=$(( width - 4 ))

	# Center align if a single line and alignment is auto
	if [ "${align}" == "a" ]; then
		if [ "${#msg}" -le "${max_width}" ]; then
			align="c"
		else
			align="l"
		fi
	fi

	local num_chars
	local indent_count
	local indent_pre
	local indent_post
	while read -r line; do
		num_chars="${#line}"
		indent_count=$(( (max_width + 2) - num_chars ))

		if [ "${align}" == "c" ]; then
			indent_pre=$(( indent_count / 2 ))
			indent_post=$(( (indent_count + 2 - 1) / 2 ))
		elif [ "${align}" == "l" ]; then
			indent_pre=1
			indent_post=$(( indent_count - 1 ))
		elif [ "${align}" == "r" ]; then
			indent_pre=$(( indent_count - 1 ))
			indent_post=1
		fi

		# Left (floor)
		echo -n "${lr_symbol}"
		for i in $(seq 1 "${indent_pre}"); do
			echo -n ' '
		done

		# Message
		echo -n "${line}"

		# Right (ceiling)
		for i in $(seq 1 "${indent_post}"); do
			echo -n ' '
		done

		echo "${lr_symbol}"
	done < <(echo "${msg}" | fold -s -w "${max_width}")

	if [ "${print_footer}" -eq 1 ]; then
		printline "${tb_symbol}" "${width}" && echo
	fi
}

# Convenience for a middle line with 80 char left align standard box
# shellcheck disable=SC2120
boxline()
{
	if [ "${#}" -eq 0 ]; then
		box "" 80 '=' '|' 'l' 0 0
	else
		for i in "${@}"; do
			box "${i}" 80 '=' '|' 'l' 0 0
		done
	fi
}

# Print a repeated line
printline()
{
	if [ $# -ne 2 ]; then
		echo "Usage: ${FUNCNAME[0]} <char> <times>"
		return 1
	fi

	printf "${1}%.0s" $(seq 1 "${2}")
}

# Convenience function to print a failure method and exit
# All params are echoed in a box with newlines in between.
fail()
{
	font_red
	echo "[FAIL]"
	echo

	if [ "${#}" -eq 1 ]; then
		box "${1}" 80 '!' '!'
	elif [ "${#}" -gt 1 ]; then
		for i in $(seq 1 "${#}"); do
			if [ "${i}" -eq 1 ]; then
				box "${!i}" 80 '!' '!' 'l' 1 0
			elif [ "${i}" -eq "${#}" ]; then
				box "${!i}" 80 '!' '!' 'l' 0 1
			else
				box "${!i}" 80 '!' '!' 'l' 0 0
			fi
		done
	fi

	font_reset

	print_footer "${start_sec}"

	# Exit from here
	exit 1
}

# Print [WARN] with any arguments in a box after.
# All params are echoed in a box with newlines in between.
warn()
{
	font_lightred
	echo "[WARN]"


	if [ "${#}" -eq 1 ]; then
		echo
		box "${1}"
	elif [ "${#}" -gt 1 ]; then
		echo
		for i in $(seq 1 "${#}"); do
			if [ "${i}" -eq 1 ]; then
				box "${!i}" 80 '=' '|' 'l' 1 0
			elif [ "${i}" -eq "${#}" ]; then
				box "${!i}" 80 '=' '|' 'l' 0 1
			else
				box "${!i}" 80 '=' '|' 'l' 0 0
			fi
		done
	fi

	font_reset
}

# Print [OKAY] with any arguments in parenthesis before.
okay()
{
	if [ $# -ne 0 ]; then
		for i in "${@}"; do
			font_dim
			echo -n "(${i}) "
			font_reset
		done
	fi
	font_green
	echo "[OKAY]"
	font_reset
}

# Check that images have been downloaded, placed in the correct spot, etc.
check_for_images()
{
	# Check for data
	echo -n "Checking for validation images... "
	if ! [ -d "${wd}/${validation_image_dir}" ]; then
		# If directory doesn't exist, maybe user didn't expand archive
		local image_archive
		image_archive=$(ls -r \
		    "${wd}"/${validation_image_download_prefix}* 2> /dev/null)
		if [ "${image_archive}" != "" ]; then
			font_yellow
			echo "[DEFER]"
			font_reset
			while read -r i; do
				echo -n "Expanding $(basename "${i}")... "
				if ! tar xf "${i}" > /dev/null 2>&1; then
					fail "Failed to expand ${i}"
				else
					okay
				fi
			done < <(find "${wd}" -maxdepth 1 -name \
			    "${validation_image_download_prefix}*")

			check_for_images
			return
		else
			msg="Cannot find validation images. You must request "
			msg+="them from NIST's website and place them within:"
			fail "${msg}" "${wd}" "The URL is:" \
			    ${validation_image_request_url}
		fi
	else
		# If the directory does exist, check that every archive present
		# has been expanded
		local has_deferred=0
		while read -r i; do
		    	local regex=".*\/${validation_image_download_prefix}"
		    	regex+="\(.*\)-.\+.tar.gz"
			local kind
			# shellcheck disable=SC2001
			kind=$(sed "s/${regex}/\1/" <<< "${i}")
			if ! [ -e \
			    "${wd}/${validation_image_dir}/VERSION-${kind}" ];
			    then
			    	if [ ${has_deferred} -eq 0 ]; then
			    		font_yellow
	    				echo "[DEFER]"
	    				font_reset
	    				has_deferred=1
	    			fi

				echo -n "Expanding $(basename "${i}")... "
				if ! tar xf "${i}" > /dev/null 2>&1; then
					fail "Failed to expand ${i}"
					return
				else
					okay
					return
				fi
			fi
		done < <(find "${wd}" -maxdepth 1 -name \
		    "${validation_image_download_prefix}*")
	fi

	okay
}

# Ensure that the imagery versions downloaded are compatible with this
# version of the validation script.
check_image_versions()
{
	echo -n "Checking validation image versions... "

	declare -A acceptable_versions
	acceptable_versions["twoinch"]="201902271132"
	acceptable_versions["threeinch"]="201902271132"
	acceptable_versions["upperpalm"]="202006111448"
	acceptable_versions["fullpalm"]="201902271132"

	local found_some_images=0
	for slapkind in ${slap_type_names}; do
		if ! [ -e "${wd}/${validation_image_dir}/VERSION-${slapkind}" ];
		    then
		    	continue
		else
			found_some_images=1
		fi

		local image_version=UNKNOWN
		read -r image_version < \
		    "${wd}/${validation_image_dir}/VERSION-${slapkind}"
		local image_version_okay=0
		for v in ${acceptable_versions[$slapkind]}; do
			if [ "${v}" == "${image_version}" ]; then
				local image_version_okay=1
			fi
		done
		if [ $image_version_okay -ne 1 ]; then
			msg="The version of ${slapkind} validation images "
			msg+="within ${wd}/${validation_image_dir} "
			msg+="(${image_version}) is not compatible with this "
			msg+="version of the validation script "
			msg+="(${validation_version}). Please request the "
			msg+="latest version from the NIST website: "
			fail "${msg}" ${validation_image_request_url}
		fi
	done

	# Check that at least one type of image was found above
	if [ ${found_some_images} -eq 0 ]; then
		msg="No images were found within within ${wd}/"
		msg+="${validation_image_dir}.  If you have images, please "
		msg+="move them to the appropriate location. If you don't have "
		msg+="images, please request the latest versions from NIST: "
		fail "${msg}" ${validation_image_request_url}
	fi

	okay
}

# Record MD5 of randomly-generated files to ensure that you truly have the
# latest version of the validation imagery
log_canaries()
{
	local canary_prefix="canary"
	find -L "${wd}"/${validation_image_dir} -name "${canary_prefix}*" \
	    -exec md5sum {} \; >> "${output_dir}"/canary.log
}

# Check that Ubuntu packages used in this file have been installed.
check_required_packages()
{
	echo -n "Checking for required packages... "

	# Packages required to run this script
	local pkgs="base-files binutils cmake coreutils curl file findutils "
	pkgs+="g++ gawk grep libc-bin make sed tar xz-utils"

	if ! command -v dpkg-query > /dev/null; then
		local msg="\`dpkg-query' is required to be installed for "
		msg+="validation. Try \`apt install dpkg' to install."
		fail "${msg}"
	fi

	for pkg in ${pkgs}; do
		if ! dpkg-query -l "${pkg}" > /dev/null 2>&1; then
			msg="The required package \"${pkg}\" was not "
			msg+="installed. Try \`apt install ${pkg}\` to install "
			msg+="\"${pkg}.\""
			fail "${msg}"
		fi
	done

	okay
}

# If the user has Internet access, check that this script is the latest version.
# @return 1 if version could be checked, 0 if not.
check_validation_version()
{
	# URL with the most recent version number of the validation package
	local version_url="https://raw.githubusercontent.com/usnistgov/"
	local version_url+="slapseg/master/slapsegiii/validation/VERSION"
	# Confirm validation package version, if possible
	local checked=0

	echo -n "Checking validation version... "
	# d.root-servers.net -> 199.7.91.13
	if ping -W 1 -c 1 199.7.91.13 > /dev/null 2>&1; then
		local internet_version=0
		if ! internet_version=$(curl -m 10 -f "${version_url}" \
		    2>/dev/null)
		then
			font_dim
			echo -n "(connection failure) "
			font_reset
			font_yellow
			echo -n "[SKIP]"
			font_reset
		else
			if [ "${internet_version}" != "${validation_version}" ];
			then
				msg="You are running an old version of the "
				msg+="validation package (${validation_version}"
				msg+="). Please download ${internet_version} "
				msg+="from:"
				fail "${msg}" "${validation_dl_url}"
			else
				okay "${validation_version}"
				checked=1
			fi
		fi
	else
		font_dim
		echo -n "(no Internet connection) "
		font_reset
		font_yellow
		echo "[SKIP]"
		font_reset
	fi

	return ${checked}
}

# Check that the version of Ubuntu is the correct version.
check_os()
{
	local expected="20.04.3 LTS (Focal Fossa)"
	echo -n "Checking OS and version... "
	if [ ! -e /etc/os-release ]; then
		local msg="You do not appear to be using the appropriate "
		msg+="operating system. Please use Ubuntu Server ${expected}."
		fail "${msg}"
	fi
	if [ "$(grep "VERSION=" /etc/os-release | cut -f 2 -d '=' | \
	    tr -d '"')" != "${expected}" ]; then
		local msg="You do not appear to be using the appropriate "
		msg+="version of Ubuntu Server. Please use ${expected}."
		fail "${msg}"
	fi
	okay "Ubuntu Server ${expected}"
}

# Check that a core library exists
core_library_present()
{
	local lib_regex="libslapsegiii_[A-Za-z0-9]+_[0-9A-F]{4}.so"

	if ! [ -d "${lib_dir}" ]; then
		return 1
	fi

	local count
	count=$(find "${lib_dir}" -type f -regextype posix-extended \
	    -regex "${lib_dir}/${lib_regex}" -printf "%P\n" | wc -l)
	if [ "${count}" != "1" ]; then
		return 1
	fi

	return 0
}

# Get the name of the core library
get_core_library_name()
{
	if ! core_library_present; then
		return 1
	fi

	local lib_regex="libslapsegiii_[A-Za-z0-9]+_[0-9A-F]{4}.so"

	if ! [ -d "${lib_dir}" ]; then
		local msg="Library directory not found. Create it and place "
		msg+="the core library inside."
		fail "${msg}" "" "The library directory is:" "${lib_dir}"
		return 1
	fi

	local core_lib=""
	local count
	count=$(find "${lib_dir}" -type f -regextype posix-extended \
	    -regex "${lib_dir}/${lib_regex}" -printf "%P\n" | wc -l)
	if [ "${count}" != "1" ]; then
		fail "More than one core library found in ${lib_dir}"
		return 1
	fi

	local core_lib
	core_lib=$(find "${lib_dir}" -type f -regextype posix-extended \
	    -regex "${lib_dir}/${lib_regex}" -printf "%P\n")
	if [ "${core_lib}" == "" ]; then
		local msg="No core library found in the library directory. "
		msg+="Please review the SlapSeg III library naming conventions."
		fail "${msg}" "" "The library directory is:" "${lib_dir}"
		return 1
	fi

	echo "${core_lib}"
}

# Get the name of the organization from the core library.
get_organization_name()
{
	local name
	if ! name="$(get_core_library_name)"; then
		return 1
	fi

	cut -f2 -d_ <<< "${name}"
}

# Get the version of the library from the core library.
get_lib_version()
{
	local name
	if ! name="$(get_core_library_name)"; then
		return 1
	fi

	(cut -f3 -d_ <<< "${name}") | sed 's/\(.*\).so/\1/'
}

# Ensure that a library in the lib directory implements the required naming
# convention.
check_library()
{
	echo -n "Looking for core library... "

	local core_lib=""
	if core_library_present; then
		if ! core_lib=$(get_core_library_name); then
			echo "${core_lib}"
			return 1
		fi
	else
		if ! get_core_library_name; then
                	local msg="No core library found in the library "
			msg+="directory. Please review the SlapSeg III "
			msg+="library naming conventions."
                	fail "${msg}" "" "The library directory is:" \
			    "${lib_dir}"
			return 1
		fi

		return 1
	fi

	# Some file systems are case-sensitive
	local vers
	vers="$(get_lib_version)"
	if [ "${vers}" != "$(tr '[:lower:]' '[:upper:]' <<< "${vers}")" ]; then
		local correct
		correct="$(cut -f1 -d_ <<< "${core_lib}")_"
		correct+="$(cut -f2 -d_ <<< "${core_lib}")_"
		correct+="$(tr '[:lower:]' '[:upper:]' <<< "${vers}")."
		correct+="$(cut -f2 -d. <<< "${core_lib}")"

		local msg="Please use uppercase hexadecimal digits "
		msg+="(\"ABCDEF\", not \"abcdef\") for the version in your "
		msg+="library name. Please rebuild \"${core_lib}\" as "
		msg+="\"${correct}.\""
		fail "${msg}"
	fi

	# If SONAME is present, check that it is the same as the lib name
	local SONAME
	SONAME=$(objdump -p "${lib_dir}/${core_lib}" | grep SONAME | \
	    awk '{print $2}')
	if [ "${SONAME}" != "" ]; then
		if [ "${SONAME}" != "${core_lib}" ]; then
			local msg="The SONAME of ${core_lib} is not valid. "
			msg+="${core_lib} was likely renamed after being "
			msg+="built. The SONAME must be the same name as the "
			msg+="core library."
			fail "${msg}"
		fi
	fi

	okay "${core_lib}"
}

# Check that you have all the images for all types of slaps you support
check_for_image_completeness()
{
	echo -n "Checking that you have all necessary kinds of images... "

	for type in ${slap_type_names}; do
		support=$("${binary}" -k | grep -i -e "${type}" | \
		    grep -c -e true)
		if [ "${support}" != "0" ]; then
			if ! [ -e "images/VERSION-${type}" ]; then
				local msg="Your library supports segmenting "
				msg+="${type} slaps, but you do not have the "
				msg+="${type} validation imagery present in "
				msg+="${validation_image_dir}."
				fail "${msg}"
			fi
		fi
	done

	okay
}

# Check the environment for known variables, and echo them.
check_environment()
{
	echo -n "Checking for known environment variables... "
	okay
}

# Get a random number.
random_number()
{
	od -A n -t uL -N 4 /dev/urandom | tr -d -C '[:digit:]'
}

# Check and warn if files from a previous validation attempt are still present
# in the current working directory.
check_for_previous_attempts()
{
	echo -n "Checking for previous validation attempts... "
	local output_found
	output_found=$(find "${wd}" -maxdepth 1 -type d -name \
	    "$(basename "${output_dir}")*" -print -quit)
	if [ "$output_found" != "" ]; then
		fail "Previous attempt at validation found:" \
		    "$(rp "${output_found}")" \
		    "You can remove it by running: '$0 clean'"
	fi
	output_found=$(find "${wd}" -maxdepth 1 -name \
	    "slapsegiii_validation_*" -a \! -name \
	    "slapsegiii_validation_images_*.tar.gz" -print -quit)
	if [ "${output_found}" != "" ]; then
		fail "Previous attempt at validation found:" \
		    "$(rp "${output_found}")" "" \
		    "You can remove it by running: '$0 clean'"
	fi

	okay
}

# Compile the validation driver.
compile()
{
	echo -n "Building... "

	if [ $# -ne 1 ]; then
		fail "Usage: ${FUNCNAME[0]} <random_seed>"
	fi

	local expected_lib_md5="11311d92e4edfc07e13351c1f1694d37"
	local actual_lib_md5
	actual_lib_md5=$(md5sum \
	    "${src_dir}"/libslapsegiii/libslapsegiii.cpp | cut -f 1 -d ' ')
	if [ "${expected_lib_md5}" != "${actual_lib_md5}" ]; then
		local msg="Your copy of libslapsegiii.cpp appears to be "
		msg+="modified. Please restore the original copy. Making "
		msg+="changes will almost certainly cause errors."
		fail "${msg}"
	fi

	local expected_h_md5="16e1e8debada90d4b89fa8e51822d9b0"
	local actual_h_md5
	actual_h_md5=$(md5sum "${src_dir}"/slapsegiii.h | cut -f 1 -d ' ')
	if [ "${expected_h_md5}" != "${actual_h_md5}" ]; then
		local msg="Your copy of slapsegiii.h appears to be "
		msg+="modified. Please restore the original copy. Making "
		msg+="changes will almost certainly cause errors."
		fail "${msg}"
	fi

	if [ -e "${lib_dir}"/libslapsegiii.so ]; then
		local msg="The library 'libslapsegiii.so' is in the directory "
		msg+="$(rp "${lib_dir}"). This script will build its own copy "
		msg+="of the library to ensure that modifications have not "
		msg+="been made, since doing so may cause issues during the "
		msg+="evaluation."
		fail "${msg}"
	fi

	# Compile
	local log="${output_dir}/compile.log"
	if ! make -C "${src_dir}" 2>&1 | tee "${log}" > /dev/null; then
		fail "An error occurred during compilation. Please review:" \
		    "${log}"
	fi

	# Check that binary shows a dependency on the core library
	local core_lib
	if ! core_lib="$(get_core_library_name)"; then
		fail "Could not get core library name"
	fi

	if ! grep -q "${lib_dir}/${core_lib}" < <(ldd "${binary}"); then
		local msg="${core_lib} is not a dependency of the compiled "
		msg+="binary. The library was either renamed after being "
		msg+="built, or the binary is linking against a version of "
		msg+="${core_lib} from a directory outside of the validation "
		msg+="package. Please review:"
		fail "${msg}" "$(rp "${log}")"
	fi

	# Log some extra compilation information that may be useful in helping
	# to debug future issues
	{
		echo "Library directory:"
		find "${lib_dir}" -type f -exec md5sum {} \;
		echo

		echo "Ubuntu Version:"
		grep "VERSION=" /etc/os-release | cut -f 2 -d '=' | tr -d '"'
		echo

		echo "ldd output of binary:"
		ldd "${binary}"
		echo

		echo "Validation properties:"
		echo "Validation Version = ${validation_version}"
		echo "Random Seed = $1"
	} >> "${log}"

	okay
}

check_api_level()
{
	echo -n "Checking API version... "

	# If API level is incorrect, text is printed to stderr on execution
	local tempfile
	tempfile=$(mktemp)
	local output
	output=$("${binary}" 2> "${tempfile}")
	if [ "$(grep -c "Incompatible " "${tempfile}")" != "0" ]; then
		output=$(<"${tempfile}")
		rm "${tempfile}"
		fail "${output}"
		return 1
	fi

	rm "${tempfile}"
	okay
}

# Remove files from previous validation attempts.
clean_previous_attempts()
{
	echo -n "Removing output directories... "
	rm -rf "${bin_dir}"
	if [ -d "${bin_dir}" ]; then
		fail "Failed to remove" "${bin_dir}"
		return 1
	fi

	rm -rf "${output_dir}"
	if [ -d "${output_dir}" ]; then
		fail "Failed to remove" "${output_dir}"
		return 1
	fi

 	rm -rf "${wd}/validation_$(get_organization_name)_"*
	if [ "$(find "${wd}" -name \
	    "validation_$(get_organization_name)_*" | wc -l)" != "0" ]; then
	    	fail "Failed to remove some output. Please delete it manually."
		return 1
	fi

	okay
}

# Log identification information to a log file.
record_identification_information()
{
	local log="${output_dir}"/id.log

	{
		echo "Core Library = $(get_core_library_name)"
		${binary} -i
		${binary} -k
	} >> "${log}"
}

# Run the validation driver for all supported slap types.
run_segmentation()
{
	echo -n "Running segmentation... "

	if [ $# -ne 1 ]; then
		fail "Usage: ${FUNCNAME[0]} <random_seed>"
	fi

	# We want to fork regardless to be sure that implementations can handle
	# forking, but we don't need to spawn a ton of processes either.
	forks=$(( $(nproc --all) > 4 ? 4 : 2 ))

	local log="${output_dir}"/run-segment.log
	local command="$binary -s -r $1 -f ${forks}"
	echo "${command}" >> "${log}"
	if ! ${command} >> "${log}" 2>&1; then
		msg="An error occurred during segmentation. Please investigate:"
		fail "${msg}" "${log}"
	fi

	# Check for runtime error messages
	if [ "$(wc -l < "${log}")" != "1" ]; then
		msg="Unexpected output  was logged during segmentation. Please "
		msg+="review:"
		fail "${msg}" "$(rp "${log}")"
	fi
	okay
}

# Run the validation driver to test calls to determineOrientation
run_determine_orientation()
{
	echo -n "Running orientation determination... "

	if [ $# -ne 1 ]; then
		fail "Usage: ${FUNCNAME[0]} <random_seed>"
	fi

	# Check if determine orientation is supported
	if [ "$($binary -k | grep DetermineOrientation | cut -f3 -d' ')" != \
	    "true" ]; then
	    	font_dim
	    	echo -n "(not implemented) "
	    	font_reset
	    	font_yellow
		echo "[SKIP]"
		font_reset
		return
	fi

	# We want to fork regardless to be sure that implementations can handle
	# forking, but we don't need to spawn a ton of processes either.
	forks=$(( $(nproc --all) > 4 ? 4 : 2 ))

	local log="${output_dir}"/run-determineOrientation.log
	local command="$binary -d -r $1 -f ${forks}"
	echo "${command}" >> "${log}"
	if ! ${command} >> "${log}" 2>&1; then
		local msg="An error occurred during orientation determination. "
		msg+="Please investigate:"
		fail "${msg}" "${log}"
	fi

	# Check for runtime error messages
	if [ "$(wc -l < "${log}")" != "1" ]; then
		local msg="Unexpected output  was logged during orientation "
		msg+="determination. Please review:"
		fail "${msg}" "$(rp "${log}")"
	fi
	okay
}

# Check segmentation logs for errors.
check_segmentation_logs()
{
	echo -n "Checking segmentation logs... "
	merge_logs "segments"
	check_segment_log_counts

	if ! check_segmentation_log_errors; then
		warn 'failure return values present'
	else
		okay
	fi
}

# Check the segmentation logs for the appropriate number of lines.
check_segment_log_counts()
{
	declare -A log_lines
	log_lines[2]=481
	log_lines[3]=553
	log_lines[5]=457
	log_lines[8]=413

	declare -A expected_logs
	expected_logs[2]=$($binary -k | grep TwoInch | cut -f3 -d' ')
	expected_logs[3]=$($binary -k | grep ThreeInch | cut -f3 -d' ')
	expected_logs[5]=$($binary -k | grep UpperPalm | cut -f3 -d' ')
	expected_logs[8]=$($binary -k | grep FullPalm | cut -f3 -d' ')

	for type in "${!log_lines[@]}"; do
		local log="${output_dir}"/segments-${type}.log
		if ! [ -e "${log}" ]; then
			if [ "${expected_logs[$type]}" == "false" ]; then
				continue
			else
				fail "An expected log was not generated." \
				    "${log}"
			fi
		fi

		if [ "$(wc -l < "${log}")" != "${log_lines[$type]}" ]; then
			msg="A segmentation log does not have the expected "
			msg+="number of lines inside. Please review:"
			fail "${msg}" "$(rp "${log}")"
		fi
	done
}

# Check segmentation logs for errors.
check_orientation_logs()
{
	echo -n "Checking orientation logs... "

	# Check if determine orientation is supported
	if [ "$($binary -k | grep DetermineOrientation | cut -f3 -d' ')" != \
	    "true" ]; then
	    	font_dim
	    	echo -n "(not implemented) "
	    	font_reset
	    	font_yellow
		echo "[SKIP]"
		font_reset
		return
	fi

	merge_logs "orientation"
	check_orientation_log_counts

	if ! check_orientation_log_errors; then
		warn 'failure return values present'
	else
		okay
	fi
}

check_orientation_log_counts()
{
	declare -A log_lines
	log_lines[2]=121
	log_lines[3]=164
	log_lines[5]=115
	log_lines[8]=104

	declare -A expected_logs
	expected_logs[2]=$($binary -k | grep TwoInch | cut -f3 -d' ')
	expected_logs[3]=$($binary -k | grep ThreeInch | cut -f3 -d' ')
	expected_logs[5]=$($binary -k | grep UpperPalm | cut -f3 -d' ')
	expected_logs[8]=$($binary -k | grep FullPalm | cut -f3 -d' ')

	for type in "${!log_lines[@]}"; do
		local log="${output_dir}/orientation-${type}.log"
		if ! [ -e "${log}" ]; then
			if [ "${expected_logs[$type]}" == "false" ]; then
				continue
			else
				fail "An expected log was not generated." \
				    "${log}"
			fi
		fi

		if [ "$(wc -l < "${log}")" != "${log_lines[$type]}" ]; then
			local msg="An orientation determination log does not "
			msg+="have the expected number of lines inside. Please "
			msg+="review:"
			fail "${msg}" "$(rp "${log}")"
		fi
	done
}

# Check that there were no odd scenarios encountered during orientation
# determination
# @return 1 if there are failure return values
# @note Non-zero return values are okay, but we want to warn the user, since
#       they might not expect this from an otherwise robust implementation, and
#       will ultimately be an incorrect answer.
check_orientation_log_errors()
{
	local has_failure_rv=0
	local error_message=""
	for type in ${slap_type_numbers}; do
		if ! [ -e "${output_dir}/orientation-${type}.log" ]; then
			continue
		fi

		local supported_but_ni=0
		local has_invalid_hand=0

		{
		read -r # Read header line
		while read -r line; do
			read -r name rv orientation <<< \
			    "$(awk -F, '{print $1,$3,$5}' <<< "${line}")"

			if [ "${rv}" != "0" ]; then
				# We fully expect failures on canary images,
				# so don't warn about them.
				if ! grep -q canary <<< "${name}"; then
					has_failure_rv=1
				fi
			fi

			# We only check orientation logs if they are supported,
			# therefore NotImplemented is not permitted.
			if [ "${rv}" == "6" ]; then
				supported_but_ni=1
				continue
			fi

			# The only valid hand positions.
			if [ "${rv}" == "0" ]; then
				if [ "${type}" == "3" ]; then
					if [ "${orientation}" != 0 ] && \
					    [ "${orientation}" != 1 ] && \
					    [ "${orientation}" != 2 ]; then
						has_invalid_hand=1
						continue
					fi
				else
					if [ "${orientation}" != "0" ] && \
					    [ "${orientation}" != "1" ]; then
						has_invalid_hand=1
						continue
					fi
				fi
			else
				if [ "${orientation}" != "NA" ]; then
					has_invalid_hand=1
					continue
				fi
			fi
		done
		} < "${output_dir}/orientation-${type}.log"

		if [ ${has_invalid_hand} -eq 1 ] || \
		    [ ${supported_but_ni} -eq 1 ]; then
		    	local p="${output_dir}"/orientation-${type}.log
		    	if [ "${error_message}" != "" ]; then
		    		error_message+="\n"
		    	fi
			error_message+="\nIn "$(rp "${p}")
			error_message+=', at least one orientation '
			error_message+='determination:'
		fi

		if [ ${supported_but_ni} -eq 1 ]; then
			error_message+='\n \x2A returned NotImplemented, but '
			error_message+='specified the opposite in '
			error_message+='getSupported().'
		fi

		if [ ${has_invalid_hand} -eq 1 ]; then
			error_message+='\n \x2A specified an orientation other '
			error_message+='than '
			if [ "${type}" == "3" ]; then
				error_message+='Left, Right, or Thumbs.'
			else
				error_message+='Left or Right.'
			fi
		fi
	done

	if [ "${error_message}" != "" ]; then
		fail "${error_message}"
	fi

	return ${has_failure_rv}
}

# Check that there were no coordinate errors or nonzero return values logged
# during segmentation.
# @return 1 if there are failure return values
# @note Non-zero return values are okay, but we want to warn the user, since
#       they might not expect this from an otherwise robust implementation.
check_segmentation_log_errors()
{
	local has_failure_rv=0
	local error_message=""
	for type in ${slap_type_numbers}; do
		if ! [ -e "${output_dir}/segments-${type}.log" ]; then
			continue
		fi

		local has_quantity_error=0
		local has_outside_coordinates=0
		local is_rotated=0
		local has_nonrectangular_coordiantes=0
		local has_irregular_coordinates=0
		local missing_deficiencies=0
		local has_deficiencies=0

		{
		read -r # Read header line
		while read -r line; do
			read -r name rv errors scode deficiencies quantity <<< \
			    "$(awk -F, '{print $1,$3,$16,$14,$17,$18}' <<< \
			    "${line}")"

			# Ensure that a deficiency is set when returning
			# RequestRecapture and RequestRecaptureWithAttempt
			if [ "${rv}" == "2" ] || [ "${rv}" == "3" ]; then
				if [ "$(tr -d '\"' <<< "${deficiencies}")" == \
				    "0000" ]; then
					missing_deficiencies=1
				fi
			elif [ "${rv}" == "0" ]; then
				if [ "$(tr -d '\"' <<< "${deficiencies}")" != \
				    "0000" ]; then
					has_deficiencies=1
				fi
			fi

			# Only check for position errors with "Success" or
			# "RequestRecaptureWithAttempt"
			if [ "${rv}" != "0" ] && [ "${rv}" != "3" ]; then
				# We fully expect failures on canary images,
				# so don't warn about them.
				if ! grep -q canary <<< "${name}"; then
					has_failure_rv=1
				fi
			fi

			if [ "${quantity}" == "0" ]; then
				has_quantity_error=1
			fi

			# Don't check coordinates unless segmentation position
			# code is "Success"
			if [ "${scode}" == "NA" ] || [ "${scode}" != "0" ]; then
				continue
			fi

			local errors
			errors="$(tr -d '"' <<< "${errors}")"
			if [ "$(cut -c 1 <<< "${errors}")" == "1" ]; then
				has_outside_coordinates=1
			fi
			if [ "$(cut -c 2 <<< "${errors}")" == "1" ]; then
				is_rotated=1
			fi
			if [ "$(cut -c 3 <<< "${errors}")" == "1" ]; then
				has_nonrectangular_coordiantes=1
			fi
			if [ "$(cut -c 4 <<< "${errors}")" == "1" ]; then
				has_irregular_coordinates=1
			fi
		done
		} < "${output_dir}/segments-${type}.log"

		if [ ${has_quantity_error} -eq 1 ] || \
		    [ ${has_outside_coordinates} -eq 1 ] || \
		    [ ${is_rotated} -eq 1 ] || \
		    [ ${has_nonrectangular_coordiantes} -eq 1 ] || \
		    [ ${has_irregular_coordinates} -eq 1 ] || \
		    [ ${has_deficiencies} -eq 1 ] || \
		    [ ${missing_deficiencies} -eq 1 ]; then
		    	local p="${output_dir}"/segments-${type}.log
		    	if [ "${error_message}" != "" ]; then
		    		error_message+="\n"
		    	fi
			error_message+="\nIn "$(rp "${p}")
			error_message+=', at least one segment:'
		fi

		if [ ${has_quantity_error} -eq 1 ]; then
			error_message+='\n \x2A has less than the appropriate '
			error_message+='number of segments.'
		fi

		if [ ${has_outside_coordinates} -eq 1 ]; then
			error_message+='\n \x2A has coordinates outside the '
			error_message+='image.'
		fi

		if [ ${is_rotated} -eq 1 ]; then
			error_message+='\n \x2A is rotated.'
		fi

		if [ ${has_nonrectangular_coordiantes} -eq 1 ]; then
			error_message+='\n \x2A has non-rectangular '
			error_message+='coordinates.'
		fi

		if [ ${missing_deficiencies} -eq 1 ]; then
			error_message+='\n \x2A returned RequestRecapture[With'
			error_message+='Attempt] but did not set a Deficiency.'
		fi

		if [ ${has_deficiencies} -eq 1 ]; then
			error_message+='\n \x2A returned Success but set a '
			error_message+='Deficiency.'
		fi

		if [ ${has_irregular_coordinates} -eq 1 ]; then
			error_message+='\n \x2A has irregular coordinates.'
		fi
	done

	if [ "${error_message}" != "" ]; then
		fail "${error_message}"
	fi

	return ${has_failure_rv}
}

# Merge forked logs into a single file.
merge_logs()
{
	if [ $# -ne 1 ]; then
		fail "Usage: ${FUNCNAME[0]} <log_prefix>"
	fi

	local log_prefix="${1}"

	exists=$(find "${output_dir}" -type f -name "${log_prefix}-*" \
	    -print -quit)

	if [ "${exists}" == "" ]; then
		fail "Could not merge ${log_prefix} logs."
	fi

	# Get the header
	local log="${output_dir}/${log_prefix}.log"
	head -n 1 "${exists}" >> "${log}"

	# Merge the logs, minus the header
	while read -r f; do
		tail -n +2 "${f}" >> "${log}"
		rm "${f}"
	done < <(find "${output_dir}" -type f -name "${log_prefix}-*")

	# Sort, ignoring the header
	(head -n 1 "${log}" && tail -n +2 "${log}" | sort) > "${log}.sort"
	rm "${log}"
	mv "${log}.sort" "${log}"
}

# Generate the name of the validation tarball.
get_tarball_name()
{
	local name
	name="slapsegiii_validation_$(get_organization_name)_"
	name+="$(get_lib_version).tar.gz"
	echo "${name}"
}

# Make a tarball of all libraries and logfiles to send to NIST.
make_tarball()
{
	echo -n "Creating validation submission... "

	local tar_file
	tar_file=$(get_tarball_name)
	local new_name
	new_name="${wd}/$(basename "$(get_tarball_name)" .tar.gz)"

	mv "${output_dir}" "${new_name}"
	cp -pr "${lib_dir}" "${new_name}"

	# NIST will build a fresh libslapsegiii.so
	if ! rm "${new_name}/$(basename "${lib_dir}")/libslapsegiii.so"; then
		local msg="An error occurred while copying libraries. Check "
		msg+="file permissions."
		fail "${msg}"
	fi
	if ! tar -C "${wd}" -c -z -f "${tar_file}" "$(basename "${new_name}")" \
	    > /dev/null; then
		fail "There was an issue creating the validation submission."
	fi

	okay "${tar_file}"
}

# Print success message.
print_final_success()
{
	local tar_file
	tar_file="$(get_tarball_name)"

	local msg="You have successfully completed your part of SlapSeg III "
	msg+="validation. Please sign and encrypt the file listed below (run "
	msg+="'${0} encrypt' for an example)."
	box "${msg}" 80 '=' '|' 'l' 1 0
	boxline
	box "${tar_file}" 80 '=' '|' 'c' 0 0
	boxline

	local file_size
	file_size="$(du -m "${tar_file}" | cut -f 1)"
	# Likely will be too big for email
	if [ "${file_size}" -ge 20 ]; then
		msg="${tar_file}.asc may be too big for NIST's email "
		msg+="server, so please contact slapseg@nist.gov for an upload "
		msg+="link for both ${tar_file}.asc and your public key."
	else
		msg="Please attach both ${tar_file}.asc and your public key to "
		msg+="an email addressed to slapseg@nist.gov."
	fi
	box "${msg}" 80 '=' '|' 'l' 0 1
	font_reset
	echo
}

# Print validation script header message
print_header()
{
	echo -n "SlapSeg III Validation (${validation_version}) -- "
	date
	printf '=%.0s' $(seq 1 80)
	echo
}

# Print message when validation version couldn't be checked
print_couldnt_check_version()
{
	# URL where information about the validation package can be found
	local info_url="https://github.com/usnistgov/slapseg/tree/master/"
	info_url+="slapsegiii/validation"

	# URL where the version of the validation driver can be found
	local vers_url="https://github.com/usnistgov/slapseg/tree/master/"
	vers_url+="slapsegiii/validation/VERSION"

	local msg="IMPORTANT: This script was unable to check, so please "
	msg+="ensure that you are using the latest version of the SlapSegIII "
	msg+="validation package before submitting. You are currently running "
	msg+="with version ${validation_version}."
	msg+="\n\nInformation:\n${info_url}\n"
	msg+="Version:\n${vers_url}\n"
	msg+="Download:\n${validation_dl_url}\n"

	echo
	printf '*%.0s' $(seq 1 80)
	echo
	echo -e -n ${msg} | fold -s
	printf '*%.0s' $(seq 1 80)
	echo
}

# Prevent against possible issues when not using GNU readlink
check_wd()
{
	if [ "${wd}" == "" ]; then
		msg="The directory containing \"validate\" could not be found, "
		msg+="possibly because you are not using GNU readlink under "
		msg+="Ubuntu. If you are, please report an issue on the "
		msg+="SlapSeg GitHub repository."
		fail "${msg}"
	fi
}

###############################################################################
###############################################################################
###############################################################################

check_wd
read -r validation_version < "${wd}"/VERSION
print_header

if [ $# -ne 0 ]; then
	if [ "$1" == "clean" ]; then
		clean_previous_attempts
		printf '=%.0s' $(seq 1 80)
		echo
		exit
	else
		echo "Usage: $0 [clean]"
		exit 1
	fi
fi

check_required_packages
check_for_previous_attempts
check_validation_version; validation_version_checked=$?
check_os
check_for_images
check_image_versions
check_library
check_environment
mkdir -p "${output_dir}"
log_canaries
seed="$(random_number)"
compile "${seed}"
check_api_level
check_for_image_completeness
record_identification_information
run_segmentation "${seed}"
check_segmentation_logs
run_determine_orientation "${seed}"
check_orientation_logs
make_tarball
print_final_success

if [ ${validation_version_checked} -eq 0 ]; then
	print_couldnt_check_version
fi
date
