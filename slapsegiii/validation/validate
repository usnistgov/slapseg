#!/bin/bash
################################################################################
# Slap Fingerprint Segmentation III Validation                                 #
#                                                                              #
# Place your properly-named library in to lib/ and then execute this script.   #
# If your implementation meets the tested requirements, an archive will be     #
# created for you to send to NIST for evaluation. The output of your           #
# implementation on your hardware must match the output generated at NIST      #
# exactly, so "forcing" the creation of the archive will not speed along your  #
# evaluation results.                                                          #
#                                                                              #
#  E-mail: slapseg@nist.gov                                                    #
#     URL: https://github.com/usnistgov/slapseg                                #
# License: This software was developed at the National Institute of Standards  #
#          and Technology (NIST) by employees of the Federal Government in the #
#          course of their official duties.  Pursuant to title 17 Section 105  #
#          of the United States Code, this software is not subject to          #
#          copyright protection and is in the public domain.  NIST assumes no  #
#          responsibility whatsoever for its use by other parties, and makes   #
#          no guarantees, expressed or implied, about its quality,             #
#          reliability, or any other characteristic.                           #
################################################################################

################################################################################
# Constants                                                                    #
################################################################################

# Time in seconds when this script was launched
start_sec="$(date +%s)"

# URL where the complete validation package can be downloaded
validation_dl_url="https://github.com/usnistgov/slapseg/releases"
# URL where the validation imagery is requested
validation_image_request_url="mailto:slapseg@nist.gov"

# Directory containing validation materials
wd="$(cd "$(dirname "${0}")" && pwd)"
# Directory containing validation images
validation_image_dir="images"
# Directory where libraries go
lib_dir="${wd}"/lib
local_lib_dir="${lib_dir}"
# Configuration directory provided to SlapSegIII::Interface implementation
config_dir="${wd}"/config
local_config_dir="${config_dir}"
# Directory where validation driver sourcecode lives
src_dir="${wd}"/src
# Directory where validation driver is built
bin_dir="${wd}"/bin
# Output directory for validation driver logs
output_dir="${wd}"/output
# Path to the compiled validation driver binary
binary="${bin_dir}/slapsegiii_validation"
# Suffix given to files set aside by this script
move_suffix=".moved"

# Prefix for downloaded validation imagery tarballs
validation_image_download_prefix=slapsegiii_validation_images_
# Names for supported slap types
slap_type_names="twoinch threeinch upperpalm fullpalm"
# Numbers for supported slap types
slap_type_numbers="2 3 5 8"

################################################################################
# Functions                                                                    #
################################################################################

# Dimmed text color
font_dim() { if [ -t 1 ]; then tput dim; fi }
# Green text color
font_green() { if [ -t 1 ]; then tput setaf 2; fi }
# Red text color
font_red() { if [ -t 1 ]; then tput setaf 1; fi }
# Light red text color
font_lightred() { if [ -t 1 ]; then tput setaf 5; fi }
# Yellow text color
font_yellow() { if [ -t 1 ]; then tput setaf 3; fi }
# Underline the text
font_underline() { if [ -t 1 ]; then tput smul; fi }
# Reset to default text color
font_reset() { if [ -t 1 ]; then tput sgr0; fi }

# Print the path of the argument relative to the current working directory
rp()
{
	realpath=realpath
	if [ "$(uname)" == "Darwin" ]; then
		realpath="/opt/local/bin/grealpath"
	fi

	${realpath} --relative-to="${PWD}" "${1}"
}

# Output string in a box
box()
{
	if [ "${#}" -lt 1 ] || [ "${#}" -gt 7 ] ; then
		echo -n "Usage: ${FUNCNAME[0]} <msg> [width=80] "
		echo "[tb_symbol='='] [lr_symbol='|'] [align=[a|l|c|r]] "
		echo "[header=0|1] [footer=0|1]"
		return 1
	fi
	local msg="${1}"
	local width=80
	if [ "${#}" -ge 2 ]; then
		width="${2}"
	fi
	local tb_symbol='='
	if [ "${#}" -ge 3 ]; then
		tb_symbol="${3}"
		if [ "${#tb_symbol}" -ne 1 ]; then
			echo "tb_symbol not a single character"
			return 1
		fi
	fi
	local lr_symbol='|'
	if [ "${#}" -ge 4 ]; then
		lr_symbol="${4}"
		if [ "${#lr_symbol}" -ne 1 ]; then
			echo "lr_symbol not a single character"
			return 1
		fi
	fi
	local align="a"
	if [ "${#}" -ge 5 ]; then
		align="${5}"
		if [ "${align}" != "c" ] && [ "${align}" != "a" ] && \
		    [ "${align}" != "l" ] && [ "${align}" != "r" ]; then
			echo "Invalid alignment value"
			return 1
		fi
	fi
	local print_header=1
	if [ "${#}" -ge 6 ]; then
		print_header="${6}"
		if [ "${print_header}" -ne 0 ] && [ "${print_header}" -ne 1 ]
		then
			echo "Invalid print_header value"
		fi
	fi
	local print_footer=1
	if [ "${#}" -eq 7 ]; then
		print_footer="${7}"
		if [ "${print_footer}" -ne 0 ] && [ "${print_footer}" -ne 1 ]
		then
			echo "Invalid print_footer value"
		fi
	fi

	if [ "${print_header}" -eq 1 ]; then
		printline "${tb_symbol}" "${width}" && echo
	fi

	local max_width=$(( width - 4 ))

	# Center align if a single line and alignment is auto
	if [ "${align}" == "a" ]; then
		if [ "${#msg}" -le "${max_width}" ]; then
			align="c"
		else
			align="l"
		fi
	fi

	local num_chars
	local indent_count
	local indent_pre
	local indent_post
	while read -r line; do
		num_chars="${#line}"
		indent_count=$(( (max_width + 2) - num_chars ))

		if [ "${align}" == "c" ]; then
			indent_pre=$(( indent_count / 2 ))
			indent_post=$(( (indent_count + 2 - 1) / 2 ))
		elif [ "${align}" == "l" ]; then
			indent_pre=1
			indent_post=$(( indent_count - 1 ))
		elif [ "${align}" == "r" ]; then
			indent_pre=$(( indent_count - 1 ))
			indent_post=1
		fi

		# Left (floor)
		echo -n "${lr_symbol}"
		for i in $(seq 1 "${indent_pre}"); do
			echo -n ' '
		done

		# Message
		echo -n "${line}"

		# Right (ceiling)
		for i in $(seq 1 "${indent_post}"); do
			echo -n ' '
		done

		echo "${lr_symbol}"
	done < <(printf "%b\n" "${msg}" | fold -s -w "${max_width}")

	if [ "${print_footer}" -eq 1 ]; then
		printline "${tb_symbol}" "${width}" && echo
	fi
}

# Convenience for a middle line with 80 char left align standard box
# shellcheck disable=SC2120
boxline()
{
	if [ "${#}" -eq 0 ]; then
		box "" 80 '=' '|' 'l' 0 0
	else
		for i in "${@}"; do
			box "${i}" 80 '=' '|' 'l' 0 0
		done
	fi
}

# Print a repeated line
printline()
{
	if [ $# -ne 2 ]; then
		echo "Usage: ${FUNCNAME[0]} <char> <times>"
		return 1
	fi

	printf "${1}%.0s" $(seq 1 "${2}")
}

# Convenience function to print a failure method and exit
# All params are echoed in a box with newlines in between.
fail()
{
	font_red
	echo "[FAIL]"
	echo

	if [ "${#}" -eq 1 ]; then
		box "${1}" 80 '!' '!'
	elif [ "${#}" -gt 1 ]; then
		for i in $(seq 1 "${#}"); do
			if [ "${i}" -eq 1 ]; then
				box "${!i}" 80 '!' '!' 'l' 1 0
			elif [ "${i}" -eq "${#}" ]; then
				box "${!i}" 80 '!' '!' 'l' 0 1
			else
				box "${!i}" 80 '!' '!' 'l' 0 0
			fi
		done
	fi

	if ! move_back_dirs; then
		echo
		local msg="Additionally, this script could not move back your "
		msg+="renamed lib and/or config directories. They may be named "
		msg+="$(rp "${local_lib_dir}${move_suffix}") and "
		msg+="$(rp "${local_config_dir}${move_suffix}") respectfully."
		box "${msg}" 80 '!' '!' 'l'
	fi

	font_reset
	echo

	print_footer "${start_sec}"

	# Exit from here
	exit 1
}

# Print [WARN] with any arguments in a box after.
# All params are echoed in a box with newlines in between.
warn()
{
	font_lightred
	echo "[WARN]"


	if [ "${#}" -eq 1 ]; then
		echo
		box "${1}"
	elif [ "${#}" -gt 1 ]; then
		echo
		for i in $(seq 1 "${#}"); do
			if [ "${i}" -eq 1 ]; then
				box "${!i}" 80 '=' '|' 'l' 1 0
			elif [ "${i}" -eq "${#}" ]; then
				box "${!i}" 80 '=' '|' 'l' 0 1
			else
				box "${!i}" 80 '=' '|' 'l' 0 0
			fi
		done
	fi

	font_reset
}

# Print [OKAY] with any arguments in parenthesis before.
okay()
{
	if [ $# -ne 0 ]; then
		for i in "${@}"; do
			font_dim
			echo -n "(${i}) "
			font_reset
		done
	fi
	font_green
	echo "[OKAY]"
	font_reset
}

# Check that images have been downloaded, placed in the correct spot, etc.
check_for_images()
{
	echo -n "Checking for unexpanded validation image tarballs... "

	# Check that every archive present has been expanded
	local has_deferred=0
	while read -r i; do
		local kind
		kind=$(cut -f 4 -d '_' <<< "$(basename "${i}")" | \
		    cut -f 1 -d '-')

		if ! [ -e "${wd}/${validation_image_dir}/VERSION-${kind}" ]
		then
			if [ ${has_deferred} -eq 0 ]; then
				font_yellow
				echo "[DEFER]"
				font_reset
				has_deferred=1
			fi

			echo -n "Expanding $(basename "${i}")... "
			if ! tar xf "${i}" > /dev/null 2>&1; then
				fail "Failed to expand ${i}"
			else
				okay
			fi
		fi
	done < <(find "${wd}" -maxdepth 1 -name \
	    "${validation_image_download_prefix}*")

	if [ ${has_deferred} -ne 0 ]; then
		echo -n "Checking for unexpanded validation image tarballs... "
	fi
	okay
}

# Ensure that the imagery versions downloaded are compatible with this
# version of the validation script.
check_image_versions()
{
	echo -n "Checking validation image versions... "

	declare -A acceptable_versions
	acceptable_versions["twoinch"]="201902271132"
	acceptable_versions["threeinch"]="201902271132"
	acceptable_versions["upperpalm"]="202006111448"
	acceptable_versions["fullpalm"]="201902271132"

	local found_some_images=0
	for slapkind in ${slap_type_names}; do
		if ! [ -e "${wd}/${validation_image_dir}/VERSION-${slapkind}" ];
		    then
		    	continue
		else
			found_some_images=1
		fi

		local image_version=UNKNOWN
		read -r image_version < \
		    "${wd}/${validation_image_dir}/VERSION-${slapkind}"
		local image_version_okay=0
		for v in ${acceptable_versions[$slapkind]}; do
			if [ "${v}" == "${image_version}" ]; then
				local image_version_okay=1
			fi
		done
		if [ $image_version_okay -ne 1 ]; then
			msg="The version of ${slapkind} validation images "
			msg+="within ${wd}/${validation_image_dir} "
			msg+="(${image_version}) is not compatible with this "
			msg+="version of the validation script "
			msg+="(${validation_version}). Please request the "
			msg+="latest version from the NIST website: "
			fail "${msg}" ${validation_image_request_url}
		fi
	done

	# Check that at least one type of image was found above
	if [ ${found_some_images} -eq 0 ]; then
		msg="No images were found within within ${wd}/"
		msg+="${validation_image_dir}.  If you have images, please "
		msg+="move them to the appropriate location. If you don't have "
		msg+="images, please request the latest versions from NIST: "
		fail "${msg}" ${validation_image_request_url}
	fi

	okay
}

# Record MD5 of randomly-generated files to ensure that you truly have the
# latest version of the validation imagery
log_canaries()
{
	local canary_prefix="canary"
	find -L "${wd}"/${validation_image_dir} -name "${canary_prefix}*" \
	    -exec md5sum {} \; >> "${output_dir}"/canary.log
}

# Check that Ubuntu packages used in this file have been installed.
check_required_packages()
{
	echo -n "Checking for required packages... "

	# Packages required to run this script
	local pkgs="base-files binutils cmake coreutils curl file findutils "
	pkgs+="g++ gawk grep libc-bin make sed tar xz-utils"

	if ! command -v dpkg-query > /dev/null; then
		local msg="\`dpkg-query' is required to be installed for "
		msg+="validation. Try \`apt install dpkg' to install."
		fail "${msg}"
	fi

	for pkg in ${pkgs}; do
		if ! dpkg-query -l "${pkg}" > /dev/null 2>&1; then
			msg="The required package \"${pkg}\" was not "
			msg+="installed. Try \`apt install ${pkg}\` to install "
			msg+="\"${pkg}.\""
			fail "${msg}"
		fi
	done

	okay
}

# If the user has Internet access, check that this script is the latest version.
# @return 1 if version could be checked, 0 if not.
check_validation_version()
{
	# URL with the most recent version number of the validation package
	local version_url="https://raw.githubusercontent.com/usnistgov/"
	local version_url+="slapseg/master/slapsegiii/validation/VERSION"
	# Confirm validation package version, if possible
	local checked=0

	echo -n "Checking validation version... "
	# d.root-servers.net -> 199.7.91.13
	if ping -W 1 -c 1 199.7.91.13 > /dev/null 2>&1; then
		local internet_version=0
		if ! internet_version=$(curl -m 10 -f "${version_url}" \
		    2>/dev/null)
		then
			font_dim
			echo -n "(connection failure) "
			font_reset
			font_yellow
			echo -n "[SKIP]"
			font_reset
		else
			if [ "${internet_version}" != "${validation_version}" ];
			then
				msg="You are running an old version of the "
				msg+="validation package (${validation_version}"
				msg+="). Please download ${internet_version} "
				msg+="from:"
				fail "${msg}" "${validation_dl_url}"
			else
				okay "${validation_version}"
				checked=1
			fi
		fi
	else
		font_dim
		echo -n "(no Internet connection) "
		font_reset
		font_yellow
		echo "[SKIP]"
		font_reset
	fi

	return ${checked}
}

# Check that the version of Ubuntu is the correct version.
check_os()
{
	local expected="20.04.3 LTS (Focal Fossa)"
	echo -n "Checking OS and version... "
	if [ ! -e /etc/os-release ]; then
		local msg="You do not appear to be using the appropriate "
		msg+="operating system. Please use Ubuntu Server ${expected}."
		fail "${msg}"
	fi
	if [ "$(grep "VERSION=" /etc/os-release | cut -f 2 -d '=' | \
	    tr -d '"')" != "${expected}" ]; then
		local msg="You do not appear to be using the appropriate "
		msg+="version of Ubuntu Server. Please use ${expected}."
		fail "${msg}"
	fi
	okay "Ubuntu Server ${expected}"
}

# Check that a core library exists
core_library_present()
{
	local lib_regex="libslapsegiii_[A-Za-z0-9]+_[0-9A-F]{4}.so"

	if ! [ -d "${lib_dir}" ]; then
		return 1
	fi

	local count
	count=$(find "${lib_dir}" -type f -regextype posix-extended \
	    -regex "${lib_dir}/${lib_regex}" -printf "%P\n" | wc -l)

	test "${count}" == "1"
}

# Get the name of the core library
get_core_library_name()
{
	if ! core_library_present; then
		return 1
	fi

	local lib_regex="libslapsegiii_[A-Za-z0-9]+_[0-9A-F]{4}.so"

	if ! [ -d "${lib_dir}" ]; then
		local msg="Library directory not found. Create it and place "
		msg+="the core library inside."
		fail "${msg}" "" "The library directory is:" "${lib_dir}"
		return 1
	fi

	local core_lib=""
	local count
	count=$(find "${lib_dir}" -type f -regextype posix-extended \
	    -regex "${lib_dir}/${lib_regex}" -printf "%P\n" | wc -l)
	if [ "${count}" != "1" ]; then
		fail "More than one core library found in ${lib_dir}"
		return 1
	fi

	local core_lib
	core_lib=$(find "${lib_dir}" -type f -regextype posix-extended \
	    -regex "${lib_dir}/${lib_regex}" -printf "%P\n")
	if [ "${core_lib}" == "" ]; then
		local msg="No core library found in the library directory. "
		msg+="Please review the SlapSeg III library naming conventions."
		fail "${msg}" "" "The library directory is:" "${lib_dir}"
		return 1
	fi

	echo "${core_lib}"
}

# Get the name of the organization from the core library.
get_organization_name()
{
	local name
	if ! name="$(get_core_library_name)"; then
		return 1
	fi

	cut -f2 -d_ <<< "${name}"
}

# Get the version of the library from the core library.
get_lib_version()
{
	local name
	if ! name="$(get_core_library_name)"; then
		return 1
	fi

	(cut -f3 -d_ <<< "${name}") | sed 's/\(.*\).so/\1/'
}

# Ensure that a library in the lib directory implements the required naming
# convention.
check_library()
{
	echo -n "Looking for core library... "

	local core_lib=""
	if core_library_present; then
		if ! core_lib=$(get_core_library_name); then
			echo "${core_lib}"
			return 1
		fi
	else
		if ! get_core_library_name; then
                	local msg="No core library found in the library "
			msg+="directory. Please review the SlapSeg III "
			msg+="library naming conventions."
                	fail "${msg}" "" "The library directory is:" \
			    "${lib_dir}"
			return 1
		fi

		return 1
	fi

	# Some file systems are case-sensitive
	local vers
	vers="$(get_lib_version)"
	if [ "${vers}" != "$(tr '[:lower:]' '[:upper:]' <<< "${vers}")" ]; then
		local correct
		correct="$(cut -f1 -d_ <<< "${core_lib}")_"
		correct+="$(cut -f2 -d_ <<< "${core_lib}")_"
		correct+="$(tr '[:lower:]' '[:upper:]' <<< "${vers}")."
		correct+="$(cut -f2 -d. <<< "${core_lib}")"

		local msg="Please use uppercase hexadecimal digits "
		msg+="(\"ABCDEF\", not \"abcdef\") for the version in your "
		msg+="library name. Please rebuild \"${core_lib}\" as "
		msg+="\"${correct}.\""
		fail "${msg}"
	fi

	# If SONAME is present, check that it is the same as the lib name
	local SONAME
	SONAME=$(objdump -p "${lib_dir}/${core_lib}" | grep SONAME | \
	    awk '{print $2}')
	if [ "${SONAME}" != "" ]; then
		if [ "${SONAME}" != "${core_lib}" ]; then
			local msg="The SONAME of ${core_lib} is not valid. "
			msg+="${core_lib} was likely renamed after being "
			msg+="built. The SONAME must be the same name as the "
			msg+="core library."
			fail "${msg}"
		fi
	fi

	okay "${core_lib}"
}

# Check that you have all the images for all types of slaps you support
check_for_image_completeness()
{
	echo -n "Checking that you have all necessary kinds of images... "

	for type in ${slap_type_names}; do
		chmod -R -w "${config_dir}"
		support=$("${binary}" -k -z "${config_dir}" | \
		    grep -i -e "${type}" | grep -c -e true)
		if [ "${support}" != "0" ]; then
			if ! [ -e "images/VERSION-${type}" ]; then
				chmod -R +w "${config_dir}"
				local msg="Your library supports segmenting "
				msg+="${type} slaps, but you do not have the "
				msg+="${type} validation imagery present in "
				msg+="${validation_image_dir}."
				fail "${msg}"
			fi
		fi
		chmod -R +w "${config_dir}"
	done

	okay
}

# Check the environment for known variables, and echo them.
check_environment()
{
	echo -n "Checking for known environment variables... "
	okay
}

# Get a random number.
random_number()
{
	od -A n -t uL -N 4 /dev/urandom | tr -d -C '[:digit:]'
}

# Return "DD MMM YYYY | HH:MM:SS ZZZ"
get_date()
{
	date "+%d %b %Y | %T %Z"
}

# Check and warn if files from a previous validation attempt are still present
# in the current working directory.
check_for_previous_attempts()
{
	echo -n "Checking for previous validation attempts... "
	local output_found
	output_found=$(find "${wd}" -maxdepth 1 -type d -name \
	    "$(basename "${output_dir}")*" -print -quit)
	if [ "$output_found" != "" ]; then
		fail "Previous attempt at validation found:" \
		    "$(rp "${output_found}")" \
		    "You can remove it by running: '$0 clean'"
	fi
	output_found=$(find "${wd}" -maxdepth 1 -name \
	    "slapsegiii_validation_*" -a \! -name \
	    "slapsegiii_validation_images_*.tar.gz" -print -quit)
	if [ "${output_found}" != "" ]; then
		fail "Previous attempt at validation found:" \
		    "$(rp "${output_found}")" "" \
		    "You can remove it by running: '$0 clean'"
	fi

	okay
}

# Compile the validation driver.
compile()
{
	echo -n "Building... "

	if [ $# -ne 1 ]; then
		fail "Usage: ${FUNCNAME[0]} <random_seed>"
	fi

	local log="${output_dir}/compile.log"

	declare -A md5s
	md5s["../libslapsegiii/libslapsegiii.cpp"]="11311d92e4edfc07e13351c1f1694d37"
	md5s["../include/slapsegiii.h"]="7b187f977252fac8c925028bf4063a41"

	# Check checksums
	local expected
	local actual
	echo "Source checksums:" >> "${log}"
	for f in "${!md5s[@]}"; do
		expected="${md5s[${f}]}"
		actual=$(md5sum "${wd}/${f}" | cut -f 1 -d ' ')
		if [ "${expected}" != "${actual}" ]; then
			local bf
			bf="$(basename "${f}")"
			local msg="Your copy of ${bf} appears to be modified. "
			msg+="Please restore the original copy. Making changes "
			msg+="will almost certainly cause errors."
			fail "${msg}"
		fi

		echo "${actual} ${f}" >> "${log}"
	done
	echo >> "${log}"

	# Check for pre-build libslapsegiii.so
	if [ -e "${local_lib_dir}/libslapsegiii.so" ]; then
		local msg="The library 'libslapsegiii.so' is in the directory "
		msg+="$(rp "${local_lib_dir}"). This script will build its own "
		msg+="copy of the library to ensure that modifications have "
		msg+="not been made, since doing so may cause issues during "
		msg+="the evaluation."
		warn "${msg}"

		echo -n "Still building... "
		rm -f "${local_lib_dir}/libslapsegiii.so"
		if [ -e "${local_lib_dir}/libslapsegiii.so" ]; then
			msg="This script could not overwrite your copy of "
			msg+="libslapsegiii.so."
			fail "${msg}"
		fi
	fi

	# Catch the case of hardcoding "../lib", etc. into library by always
	# linking against libs in a different directory
	local tmp_dir
	tmp_dir="$(mktemp -u -t slapsegiii_libs.XXXXXXXXXX)"
	mkdir -p "${tmp_dir}"
	cp -r "${lib_dir}" "${tmp_dir}/lib"
	lib_dir="${tmp_dir}/lib"
	if [ -d "${local_lib_dir}${move_suffix}" ]; then
		move_back_dirs

		local msg="You have a directory named ${local_lib_dir}"
		msg+="${move_suffix}. Please remove or rename it."
		fail "${msg}"
	else
		if ! mv -n "${local_lib_dir}" "${local_lib_dir}${move_suffix}"
		then
			fail "Could not move ${local_lib_dir}"
		fi
		local_lib_dir="${local_lib_dir}${move_suffix}"
	fi

	tmp_dir="$(mktemp -u -t slapsegiii_configs.XXXXXXXXXX)"
	cp -r "${config_dir}" "${tmp_dir}"
	chmod -R -w "${tmp_dir}"
	config_dir="${tmp_dir}"
	if [ -d "${local_config_dir}${move_suffix}" ]; then
		move_back_dirs

		local msg="You have a directory named ${local_config_dir}"
		msg+="${move_suffix}. Please remove or rename it."
		fail "${msg}"
	else
		if ! mv -n "${local_config_dir}" \
		    "${local_config_dir}${move_suffix}"
		then
			fail "Could not move ${local_config_dir}"
		fi
		local_config_dir="${local_config_dir}${move_suffix}"
	fi

	# Compile
	echo "Compilation:" >> "${log}"
	local build_dir
	build_dir="$(mktemp -d -t slapsegiii_validation_build.XXXXXXXXXX)"
	if [ "${build_dir}" == "" ]; then
		fail "Could not create build directory."
	fi
	cd "${build_dir}" || fail "Could not change to build directory"
	if ! cmake \
	    -DCMAKE_INSTALL_PREFIX="$(dirname "${lib_dir}")" \
	    -S "${src_dir}" -B "${build_dir}" >> "${log}" 2>&1
	then
		local msg="Could not change back to previous directory"
		cd "${wd}" > /dev/null || fail "${msg}"
		fail "An error occurred during configuration. Please review:" \
		    "$(rp "${log}")"
	fi
	cd "${wd}" > /dev/null || fail "Could not change back to previous directory"
	if ! make -C "${build_dir}" VERBOSE=1 >> "${log}" 2>&1; then
		fail "An error occurred during compilation. Please review:" \
		    "$(rp "${log}")"
	fi
	if ! make -C "${build_dir}" install VERBOSE=1 >> "${log}" 2>&1; then
		fail "An error occurred during installation. Please review:" \
		    "$(rp "${log}")"
	fi
	echo >> "${log}"

	# Check that binary shows a dependency on the core library
	local core_lib
	if ! core_lib="$(get_core_library_name)"; then
		fail "Could not get core library name"
	fi
	if ! grep -q "${lib_dir}/${core_lib}" < <(ldd "${binary}"); then
		local msg="${core_lib} is not a dependency of the compiled "
		msg+="binary. The library was either renamed after being "
		msg+="built, or the binary is linking against a version of "
		msg+="${core_lib} from a directory outside of the validation "
		msg+="package. Please review:"
		fail "${msg}" "$(rp "${log}")"
	fi

	# Check for ORIGIN if using multiple libraries
	local num_libs
	num_libs="$(find "${lib_dir}" -name "lib*" -type f | wc -l)"
	if [ "${num_libs}" -gt 2 ]; then
		if ! readelf -d "${lib_dir}/${core_lib}" | \
		    grep RUNPATH | grep "\$ORIGIN" > /dev/null
		then
			local msg="You have supplied multiple libraries, but "
			msg+="${core_lib} does not have an RUNPATH of \$ORIGIN."
			msg+=" This may cause runtime issues, because the "
			msg+="location of libraries on NIST's systems will not "
			msg+="be laid out the same as in this validation "
			msg+="package and the only library explicitly linked "
			msg+="will be ${core_lib}."

			warn "${msg}"
			echo -n "Still building... "
		fi
	fi

	# Suspected non libraries in library directory
	local non_libs
	non_libs="$(find "${local_lib_dir}" \! -name "lib*" -a \! \
	    -name README | wc -l)"
	if [ "${non_libs}" -gt 0 ]; then
		local msg="You have files in ${local_lib_dir} that don't "
		msg+="appear to be libraries. That's fine, but are you sure "
		msg+="they don't belong in \"${local_config_dir}\" instead?"

		warn "${msg}"
		echo -n "Still building... "
	fi

	# Log some extra compilation information that may be useful in helping
	# to debug future issues
	{
		echo "Library directory:"
		find "${lib_dir}" -type f -exec md5sum {} \;
		echo

		echo "Configs present:"
		find "${config_dir}" -type f \! -name README -exec md5sum {} \;
		echo

		echo "Ubuntu Version:"
		grep "VERSION=" /etc/os-release | cut -f 2 -d '=' | tr -d '"'
		echo

		echo "ldd output of binary:"
		ldd "${binary}"
		echo

		echo "Validation properties:"
		echo "Validation Version = ${validation_version}"
		echo "Random Seed = $1"
	} >> "${log}"

	okay
}

check_api_level()
{
	echo -n "Checking API version... "

	# If API level is incorrect, text is printed to stderr on execution
	local tempfile
	tempfile=$(mktemp)
	local output
	output=$("${binary}" 2> "${tempfile}")
	if [ "$(grep -c "Incompatible " "${tempfile}")" != "0" ]; then
		output=$(<"${tempfile}")
		rm "${tempfile}"
		fail "${output}"
		return 1
	fi

	rm "${tempfile}"
	okay
}

# Remove files from previous validation attempts.
clean_previous_attempts()
{
	echo -n "Removing output directories... "
	rm -rf "${bin_dir}"
	if [ -d "${bin_dir}" ]; then
		fail "Failed to remove" "${bin_dir}"
		return 1
	fi

	rm -rf "${output_dir}"
	if [ -d "${output_dir}" ]; then
		fail "Failed to remove" "${output_dir}"
		return 1
	fi

	rm -f "${lib_dir}/libslapsegiii.so"
	rm -rf "${wd}/include"

	local org_name
	if ! org_name="$(get_organization_name)"; then
		fail "Could not get organization name."
	fi

	find /tmp -maxdepth 1 -type d -name 'slapsegiii_libs.*' \
	    -exec rm -rf {} \;
	find /tmp -maxdepth 1 -type d -name 'slapsegiii_validation_build.*' \
	    -exec rm -rf {} \;

 	rm -rf "${wd}/slapsegiii_validation_${org_name}_"*
	if [ "$(find "${wd}" -name \
	    "slapsegiii_validation_${org_name}_*" | wc -l)" != "0" ]; then
	    	fail "Failed to remove some output. Please delete it manually."
		return 1
	fi

	okay
}

# Log identification information to a log file.
record_identification_information()
{
	local log="${output_dir}"/id.log

	chmod -R -w "${config_dir}"
	{
		echo "Core Library = $(get_core_library_name)"
		${binary} -i -z "${config_dir}"
		${binary} -k -z "${config_dir}"
	} >> "${log}"
	chmod -R +w "${config_dir}"
}

# Run the validation driver for all supported slap types.
run_segmentation()
{
	echo -n "Running segmentation... "

	if [ $# -ne 1 ]; then
		fail "Usage: ${FUNCNAME[0]} <random_seed>"
	fi

	# We want to fork regardless to be sure that implementations can handle
	# forking, but we don't need to spawn a ton of processes either.
	forks=$(( $(nproc --all) > 4 ? 4 : 2 ))

	local log="${output_dir}"/run-segment.log
	local command="$binary -s -r $1 -f ${forks} -z ${config_dir}"
	echo "${command}" >> "${log}"
	chmod -R -w "${config_dir}"
	if ! ${command} >> "${log}" 2>&1; then
		msg="An error occurred during segmentation. Please investigate:"
		fail "${msg}" "${log}"
	fi
	chmod -R +w "${config_dir}"

	# Check for runtime error messages
	if [ "$(wc -l < "${log}")" != "1" ]; then
		msg="Unexpected output  was logged during segmentation. Please "
		msg+="review:"
		fail "${msg}" "$(rp "${log}")"
	fi
	okay
}

# Run the validation driver to test calls to determineOrientation
run_determine_orientation()
{
	echo -n "Running orientation determination... "

	if [ $# -ne 1 ]; then
		fail "Usage: ${FUNCNAME[0]} <random_seed>"
	fi

	# Check if determine orientation is supported
	chmod -R -w "${config_dir}"
	if [ "$($binary -k -z "${config_dir}" | grep DetermineOrientation | \
	    cut -f3 -d' ')" != "true" ]; then
		chmod -R +w "${config_dir}"
	    	font_dim
	    	echo -n "(not implemented) "
	    	font_reset
	    	font_yellow
		echo "[SKIP]"
		font_reset
		return
	fi
	chmod -R +w "${config_dir}"

	# We want to fork regardless to be sure that implementations can handle
	# forking, but we don't need to spawn a ton of processes either.
	forks=$(( $(nproc --all) > 4 ? 4 : 2 ))

	local log="${output_dir}"/run-determineOrientation.log
	local command="$binary -d -r $1 -f ${forks} -z ${config_dir}"
	echo "${command}" >> "${log}"
	chmod -R -w "${config_dir}"
	if ! ${command} >> "${log}" 2>&1; then
		local msg="An error occurred during orientation determination. "
		msg+="Please investigate:"
		fail "${msg}" "${log}"
	fi
	chmod -R +w "${config_dir}"

	# Check for runtime error messages
	if [ "$(wc -l < "${log}")" != "1" ]; then
		local msg="Unexpected output  was logged during orientation "
		msg+="determination. Please review:"
		fail "${msg}" "$(rp "${log}")"
	fi
	okay
}

# Check segmentation logs for errors.
check_segmentation_logs()
{
	echo -n "Checking segmentation logs... "
	merge_logs "segments"
	check_segment_log_counts

	if ! check_segmentation_log_errors; then
		warn 'failure return values present'
	else
		okay
	fi
}

# Check the segmentation logs for the appropriate number of lines.
check_segment_log_counts()
{
	declare -A log_lines
	log_lines[2]=481
	log_lines[3]=553
	log_lines[5]=457
	log_lines[8]=413

	declare -A expected_logs
	chmod -R -w "${config_dir}"
	expected_logs[2]=$($binary -k -z "${config_dir}" | grep TwoInch | cut -f3 -d' ')
	expected_logs[3]=$($binary -k -z "${config_dir}" | grep ThreeInch | cut -f3 -d' ')
	expected_logs[5]=$($binary -k -z "${config_dir}" | grep UpperPalm | cut -f3 -d' ')
	expected_logs[8]=$($binary -k -z "${config_dir}" | grep FullPalm | cut -f3 -d' ')
	chmod -R +w "${config_dir}"

	for type in "${!log_lines[@]}"; do
		local log="${output_dir}"/segments-${type}.log
		if ! [ -e "${log}" ]; then
			if [ "${expected_logs[$type]}" == "false" ]; then
				continue
			else
				fail "An expected log was not generated." \
				    "${log}"
			fi
		fi

		if [ "$(wc -l < "${log}")" != "${log_lines[$type]}" ]; then
			msg="A segmentation log does not have the expected "
			msg+="number of lines inside. Please review:"
			fail "${msg}" "$(rp "${log}")"
		fi
	done
}

# Check segmentation logs for errors.
check_orientation_logs()
{
	echo -n "Checking orientation logs... "

	# Check if determine orientation is supported
	chmod -R -w "${config_dir}"
	if [ "$($binary -k -z "${config_dir}" | grep DetermineOrientation | \
	    cut -f3 -d' ')" != "true" ]; then
		chmod -R +w "${config_dir}"
	    	font_dim
	    	echo -n "(not implemented) "
	    	font_reset
	    	font_yellow
		echo "[SKIP]"
		font_reset
		return
	fi
	chmod -R +w "${config_dir}"

	merge_logs "orientation"
	check_orientation_log_counts

	if ! check_orientation_log_errors; then
		warn 'failure return values present'
	else
		okay
	fi
}

check_orientation_log_counts()
{
	declare -A log_lines
	log_lines[2]=121
	log_lines[3]=164
	log_lines[5]=115
	log_lines[8]=104

	declare -A expected_logs
	chmod -R -w "${config_dir}"
	expected_logs[2]=$($binary -k -z "${config_dir}" | grep TwoInch | cut -f3 -d' ')
	expected_logs[3]=$($binary -k -z "${config_dir}" | grep ThreeInch | cut -f3 -d' ')
	expected_logs[5]=$($binary -k -z "${config_dir}" | grep UpperPalm | cut -f3 -d' ')
	expected_logs[8]=$($binary -k -z "${config_dir}" | grep FullPalm | cut -f3 -d' ')
	chmod -R +w "${config_dir}"

	for type in "${!log_lines[@]}"; do
		local log="${output_dir}/orientation-${type}.log"
		if ! [ -e "${log}" ]; then
			if [ "${expected_logs[$type]}" == "false" ]; then
				continue
			else
				fail "An expected log was not generated." \
				    "${log}"
			fi
		fi

		if [ "$(wc -l < "${log}")" != "${log_lines[$type]}" ]; then
			local msg="An orientation determination log does not "
			msg+="have the expected number of lines inside. Please "
			msg+="review:"
			fail "${msg}" "$(rp "${log}")"
		fi
	done
}

# Check that there were no odd scenarios encountered during orientation
# determination
# @return 1 if there are failure return values
# @note Non-zero return values are okay, but we want to warn the user, since
#       they might not expect this from an otherwise robust implementation, and
#       will ultimately be an incorrect answer.
check_orientation_log_errors()
{
	local has_failure_rv=0
	local error_message=""
	for type in ${slap_type_numbers}; do
		if ! [ -e "${output_dir}/orientation-${type}.log" ]; then
			continue
		fi

		local supported_but_ni=0
		local has_invalid_hand=0

		{
		read -r # Read header line
		while read -r line; do
			read -r name rv orientation <<< \
			    "$(awk -F, '{print $1,$3,$5}' <<< "${line}")"

			if [ "${rv}" != "0" ]; then
				# We fully expect failures on canary images,
				# so don't warn about them.
				if ! grep -q canary <<< "${name}"; then
					has_failure_rv=1
				fi
			fi

			# We only check orientation logs if they are supported,
			# therefore NotImplemented is not permitted.
			if [ "${rv}" == "6" ]; then
				supported_but_ni=1
				continue
			fi

			# The only valid hand positions.
			if [ "${rv}" == "0" ]; then
				if [ "${type}" == "3" ]; then
					if [ "${orientation}" != 0 ] && \
					    [ "${orientation}" != 1 ] && \
					    [ "${orientation}" != 2 ]; then
						has_invalid_hand=1
						continue
					fi
				else
					if [ "${orientation}" != "0" ] && \
					    [ "${orientation}" != "1" ]; then
						has_invalid_hand=1
						continue
					fi
				fi
			else
				if [ "${orientation}" != "NA" ]; then
					has_invalid_hand=1
					continue
				fi
			fi
		done
		} < "${output_dir}/orientation-${type}.log"

		if [ ${has_invalid_hand} -eq 1 ] || \
		    [ ${supported_but_ni} -eq 1 ]; then
		    	local p="${output_dir}"/orientation-${type}.log
		    	if [ "${error_message}" != "" ]; then
		    		error_message+="\n"
		    	fi
			error_message+="\nIn "$(rp "${p}")
			error_message+=', at least one orientation '
			error_message+='determination:'
		fi

		if [ ${supported_but_ni} -eq 1 ]; then
			error_message+='\n \x2A returned NotImplemented, but '
			error_message+='specified the opposite in '
			error_message+='getSupported().'
		fi

		if [ ${has_invalid_hand} -eq 1 ]; then
			error_message+='\n \x2A specified an orientation other '
			error_message+='than '
			if [ "${type}" == "3" ]; then
				error_message+='Left, Right, or Thumbs.'
			else
				error_message+='Left or Right.'
			fi
		fi
	done

	if [ "${error_message}" != "" ]; then
		fail "${error_message}"
	fi

	return ${has_failure_rv}
}

# Return 1 if finger is not possible with hand position
# 1: Hand FGP
# 2: Finger FGP
check_hand_finger_code()
{
	if [ ${#} -ne 2 ]; then
		echo "Usage: ${FUNCNAME[0]} <hand_fgp> <finger_fgp>"
		return 1
	fi
	local hand="${1}"
	local finger="${2}"

	if [ "${hand}" -eq 13 ] || [ "${hand}" -eq 21 ] || [ "${hand}" -eq 26 ]
	then
		if [ "${finger}" -lt 2 ] || [ "${finger}" -gt 5 ]; then
			return 1
		fi
	elif [ "${hand}" -eq 14 ] || [ "${hand}" -eq 23 ] || \
	[ "${hand}" -eq 28 ]; then
		if [ "${finger}" -lt 7 ] || [ "${finger}" -gt 10 ]; then
			return 1
		fi
	elif [ "${hand}" -eq 15 ]; then
		if [ "${finger}" -ne 1 ] && [ "${finger}" -ne 6 ]; then
			return 1
		fi
	fi
}

# Check that there were no coordinate errors or nonzero return values logged
# during segmentation.
# @return 1 if there are failure return values
# @note Non-zero return values are okay, but we want to warn the user, since
#       they might not expect this from an otherwise robust implementation.
check_segmentation_log_errors()
{
	local has_failure_rv=0
	local error_message=""
	for type in ${slap_type_numbers}; do
		if ! [ -e "${output_dir}/segments-${type}.log" ]; then
			continue
		fi

		local has_quantity_error=0
		local has_outside_coordinates=0
		local is_rotated=0
		local has_nonrectangular_coordiantes=0
		local has_irregular_coordinates=0
		local has_frgp_error=0
		local missing_deficiencies=0
		local has_deficiencies=0

		{
		read -r # Read header line
		while read -r line; do
			read -r name rv frgp errors scode deficiencies \
			    quantity <<< \
			    "$(awk -F, '{print $1,$3,$5,$16,$14,$17,$18}' <<< \
			    "${line}")"

			# Ensure that a deficiency is set when returning
			# RequestRecapture and RequestRecaptureWithAttempt
			if [ "${rv}" == "2" ] || [ "${rv}" == "3" ]; then
				if [ "$(tr -d '\"' <<< "${deficiencies}")" == \
				    "0000" ]; then
					missing_deficiencies=1
				fi
			elif [ "${rv}" == "0" ]; then
				if [ "$(tr -d '\"' <<< "${deficiencies}")" != \
				    "0000" ]; then
					has_deficiencies=1
				fi
			fi

			# Check finger positions
			local hand_fgp
			hand_fgp="$(cut -f4 -d_ <<< "${name}")"
			# Canary images are assumed to be right hand
			if grep -q canary <<< "${name}"; then
				hand_fgp=13
			fi
			if ! check_hand_finger_code "${hand_fgp}" "${frgp}";
			then
				has_frgp_error=1
			fi

			# Only check for position errors with "Success" or
			# "RequestRecaptureWithAttempt"
			if [ "${rv}" != "0" ] && [ "${rv}" != "3" ]; then
				# We fully expect failures on canary images,
				# so don't warn about them.
				if ! grep -q canary <<< "${name}"; then
					has_failure_rv=1
				fi
			fi

			if [ "${quantity}" == "0" ]; then
				has_quantity_error=1
			fi

			# Don't check coordinates unless segmentation position
			# code is "Success"
			if [ "${scode}" == "NA" ] || [ "${scode}" != "0" ]; then
				continue
			fi

			local errors
			errors="$(tr -d '"' <<< "${errors}")"
			if [ "$(cut -c 1 <<< "${errors}")" == "1" ]; then
				has_outside_coordinates=1
			fi
			if [ "$(cut -c 2 <<< "${errors}")" == "1" ]; then
				is_rotated=1
			fi
			if [ "$(cut -c 3 <<< "${errors}")" == "1" ]; then
				has_nonrectangular_coordiantes=1
			fi
			if [ "$(cut -c 4 <<< "${errors}")" == "1" ]; then
				has_irregular_coordinates=1
			fi
		done
		} < "${output_dir}/segments-${type}.log"

		if [ ${has_quantity_error} -eq 1 ] || \
		    [ ${has_outside_coordinates} -eq 1 ] || \
		    [ ${is_rotated} -eq 1 ] || \
		    [ ${has_nonrectangular_coordiantes} -eq 1 ] || \
		    [ ${has_irregular_coordinates} -eq 1 ] || \
		    [ ${has_deficiencies} -eq 1 ] || \
		    [ ${has_frgp_error} -eq 1 ] || \
		    [ ${missing_deficiencies} -eq 1 ]; then
		    	local p="${output_dir}"/segments-${type}.log
		    	if [ "${error_message}" != "" ]; then
		    		error_message+="\n"
		    	fi
			error_message+="\nIn "$(rp "${p}")
			error_message+=', at least one segment:'
		fi

		if [ ${has_quantity_error} -eq 1 ]; then
			error_message+='\n \x2A has less than the appropriate '
			error_message+='number of segments.'
		fi

		if [ ${has_outside_coordinates} -eq 1 ]; then
			error_message+='\n \x2A has coordinates outside the '
			error_message+='image.'
		fi

		if [ ${is_rotated} -eq 1 ]; then
			error_message+='\n \x2A is rotated.'
		fi

		if [ ${has_nonrectangular_coordiantes} -eq 1 ]; then
			error_message+='\n \x2A has non-rectangular '
			error_message+='coordinates.'
		fi

		if [ ${missing_deficiencies} -eq 1 ]; then
			error_message+='\n \x2A returned RequestRecapture[With'
			error_message+='Attempt] but did not set a Deficiency.'
		fi

		if [ ${has_frgp_error} -eq 1 ]; then
			error_message+='\n \x2A Set an invalid FrictionRidge'
			error_message+="GeneralizedPosition (e.g. Unknown (0) "
			error_message+="or an FGP from the wrong hand."
		fi

		if [ ${has_deficiencies} -eq 1 ]; then
			error_message+='\n \x2A returned Success but set a '
			error_message+='Deficiency.'
		fi

		if [ ${has_irregular_coordinates} -eq 1 ]; then
			error_message+='\n \x2A has irregular coordinates.'
		fi
	done

	if [ "${error_message}" != "" ]; then
		fail "${error_message}\n"
	fi

	return ${has_failure_rv}
}

# Merge forked logs into a single file.
merge_logs()
{
	if [ $# -ne 1 ]; then
		fail "Usage: ${FUNCNAME[0]} <log_prefix>"
	fi

	local log_prefix="${1}"

	for type in ${slap_type_numbers}; do
		exists=$(find "${output_dir}" -type f -name \
		    "${log_prefix}-${type}-*" -print -quit)
		if [ "${exists}" == "" ]; then
			continue
		fi

		# Get the header
		local log="${output_dir}/${log_prefix}-${type}.log"

		head -n 1 "${exists}" >> "${log}"
		# Merge the logs, minus the header
		while read -r f; do
			tail -n +2 "${f}" >> "${log}"
			rm "${f}"
		done< <(find "${output_dir}" -type f -name \
		    "${log_prefix}-${type}-*")

		# Sort, ignoring the header
		(head -n 1 "${log}" && tail -n +2 "${log}" | sort) > \
		    "${log}.sort"
		rm "${log}"
		mv "${log}.sort" "${log}"
	done
}

# Generate the name of the validation tarball.
get_tarball_name()
{
	local name
	name="slapsegiii_validation_$(get_organization_name)_"
	name+="$(get_lib_version).tar.gz"
	echo "${name}"
}

# Make a tarball of all libraries and logfiles to send to NIST.
make_tarball()
{
	echo -n "Creating validation submission... "

	local tar_file
	tar_file=$(get_tarball_name)
	local new_name
	new_name="${wd}/$(basename "$(get_tarball_name)" .tar.gz)"

	mv "${output_dir}" "${new_name}"
	cp -pr "${lib_dir}" "${new_name}"
	cp -pr "${config_dir}" "${new_name}"

	# NIST will build a fresh libslapsegiii.so
	if ! rm "${new_name}/$(basename "${lib_dir}")/libslapsegiii.so"; then
		local msg="An error occurred while copying libraries. Check "
		msg+="file permissions."
		fail "${msg}"
	fi
	if ! tar -C "${wd}" -c -z -f "${tar_file}" "$(basename "${new_name}")" \
	    > /dev/null; then
		fail "There was an issue creating the validation submission."
	fi

	okay "${tar_file}"
}

# Print success message.
print_final_success()
{
	local tar_file
	tar_file="$(get_tarball_name)"

	local msg="You have successfully completed your part of SlapSeg III "
	msg+="validation. Please sign and encrypt the file listed below (run "
	msg+="'${0} encrypt' for an example)."
	box "${msg}" 80 '=' '|' 'l' 1 0
	boxline
	box "${tar_file}" 80 '=' '|' 'c' 0 0
	boxline

	local file_size
	file_size="$(du -m "${tar_file}" | cut -f 1)"
	# Likely will be too big for email
	if [ "${file_size}" -ge 20 ]; then
		msg="${tar_file}.asc may be too big for NIST's email "
		msg+="server, so please contact slapseg@nist.gov for an upload "
		msg+="link for both ${tar_file}.asc and your public key."
	else
		msg="Please attach both ${tar_file}.asc and your public key to "
		msg+="an email addressed to slapseg@nist.gov."
	fi
	box "${msg}" 80 '=' '|' 'l' 0 1
	font_reset
	echo
}

# Print validation script header message
print_header()
{
	local msg="SlapSeg III Validation | Version ${validation_version} | "
	msg+="$(get_date)"
	box "${msg}"
}

# Print validation script footer message
print_footer()
{
	local start_sec
	if [ "${#}" -eq 1 ]; then
		start_sec="${1}"
	fi

	font_reset
	font_dim
	echo -n "Completed: $(get_date)"
	if [ "${start_sec}" != "" ]; then
		local duration=$(( ("$(date +%s)" - start_sec) ))
		echo " (Runtime: ${duration}s)"
	else
		echo
	fi
	font_reset
}

print_encryption()
{
	local tar_file
	if ! tar_file="$(get_tarball_name)"; then
		tar_file="slapsegiii_validation_nullimpl_0001.tar.xz"
	fi

	# Sign + encrypt example
	echo "Example of signing and encrypting with GnuPG:"
	echo "  gpg --output ${tar_file}.asc \\"
	echo "      --default-key <!-- YOUR EMAIL ADDRESS --> \\"
	echo "      --recipient <!-- YOUR EMAIL ADDRESS --> \\"
	echo "      --recipient slapseg@nist.gov \\"
	echo "      --armor --sign --encrypt ${tar_file}"
	echo

	# Extract public key example
	local lib_name
	if ! lib_name="$(get_core_library_name)"; then
		lib_name="libslapiii_nullimpl_0001.so"
	fi
	lib_name="$(basename "${lib_name}" .so)"
	echo "Example of extracting public key with GnuPG:"
	echo "  gpg --output ${lib_name}_public_key.asc \\"
	echo "      --armor --export <!-- YOUR EMAIL ADDRESS -->"
	echo

	# Export key fingerprint example
	echo "Example of extracting fingerprint from public key with GnuPG:"
	echo "  gpg --fingerprint <!-- YOUR EMAIL ADDRESS --> | grep '^ '"
}

# Print instructions to the console
print_instructions()
{
	echo "$0 clean"
	echo -n " - Restores validation directory to original state, removing "
	echo "any previous "
	echo "   output, but leaving copied libraries and configurations."
	echo
	echo "$0 encrypt"
	echo " - Print sample signing and encryption instructions for GnuPG."
	echo
	echo "Instructions"
	echo "============"
	echo " 1. Copy required files:"
	echo -n "    a. Place all needed libraries in 'lib/', including your "
	echo "properly named "
	echo "       SlapSeg III core library."
	echo " 2. Run './validate'."
	echo "    a. Successful? Sign and encrypt the generated archive."
	echo "    b. Unsuccessful? Work to resolve the listed errors, run"
	echo "       './validate clean', and repeat these steps."
	echo -n " 3. Email the signed and encrypted file along with your "
	echo "public key to"
	echo "    slapseg@nist.gov."
}

# Print message when validation version couldn't be checked
print_couldnt_check_version()
{
	# URL where information about the validation package can be found
	local info_url="https://github.com/usnistgov/slapseg/tree/master/"
	info_url+="slapsegiii/validation"

	# URL where the version of the validation driver can be found
	local vers_url="https://github.com/usnistgov/slapseg/tree/master/"
	vers_url+="slapsegiii/validation/VERSION"

	local msg="IMPORTANT: This script was unable to check, so please "
	msg+="ensure that you are using the latest version of the SlapSegIII "
	msg+="validation package before submitting. You are currently running "
	msg+="with version ${validation_version}."
	msg+="\n\nInformation:\n${info_url}\n"
	msg+="Version:\n${vers_url}\n"
	msg+="Download:\n${validation_dl_url}\n"

	echo
	printf '*%.0s' $(seq 1 80)
	echo
	echo -e -n ${msg} | fold -s
	printf '*%.0s' $(seq 1 80)
	echo
}

# Prevent against possible issues when not using GNU readlink
check_wd()
{
	if [ "${wd}" == "" ]; then
		msg="The directory containing \"validate\" could not be found, "
		msg+="possibly because you are not using GNU readlink under "
		msg+="Ubuntu. If you are, please report an issue on the "
		msg+="SlapSeg GitHub repository."
		fail "${msg}"
	fi
}

move_back_dirs()
{
	local rv=0

	local original_path
	original_path="$(dirname "${local_lib_dir}")/"
	original_path+="$(basename "${local_lib_dir}" "${move_suffix}")"
	if ! [ -d "${original_path}" ]; then
		if mv -n "${local_lib_dir}" "${original_path}" > \
		     /dev/null 2>&1
		then
			local_lib_dir="${original_path}"
		else
			rv=1
		fi
	fi

	original_path="$(dirname "${local_config_dir}")/"
	original_path+="$(basename "${local_config_dir}" "${move_suffix}")"
	if ! [ -d "${original_path}" ]; then
		if mv -n "${local_config_dir}" "${original_path}" > \
		   /dev/null 2>&1
		then
			local_config_dir="${original_path}"
		else
			rv=1
		fi
	fi

	return "${rv}"
}

###############################################################################
###############################################################################
###############################################################################

# Move directories back on SIGINT
trap move_back_dirs INT

check_wd
cd "${wd}" || exit 1
read -r validation_version < "${wd}"/VERSION
print_header

if [ "${#}" -ne 0 ]; then
	if [ "${1}" == "clean" ]; then
		clean_previous_attempts
		exit
	elif [ "${1}" == "encrypt" ]; then
		print_encryption
		exit
	elif [ "${1}" == "help" ]; then
		print_instructions
		exit
	else
		echo "Usage: ${0} [clean|encrypt|help]"
		print_instructions
		exit 1
	fi
else
	# Quick check to see if it looks like we're fresh
	if ! core_library_present; then
		print_instructions
		exit
	fi
fi

check_required_packages
check_for_previous_attempts
check_validation_version; validation_version_checked=$?
check_os
check_for_images
check_image_versions
check_library
check_environment
mkdir -p "${output_dir}"
log_canaries
seed="$(random_number)"
compile "${seed}"
check_api_level
check_for_image_completeness
record_identification_information
run_segmentation "${seed}"
check_segmentation_logs
run_determine_orientation "${seed}"
check_orientation_logs

# Cleanup
move_back_dirs
make_tarball
print_final_success

if [ ${validation_version_checked} -eq 0 ]; then
	print_couldnt_check_version
fi
date
